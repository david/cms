# .goosehints

## Project Overview

- **Type:** Elixir/Phoenix Web Application
- **Location:** This file resides in the project root directory. Run commands from here.
- **Note:** This project uses git worktrees; the specific root directory path might vary (e.g., `/var/home/david/Projects/chr/some-branch`).

## Development Guidelines

### CRITICAL - NO CODE COMMENTS
**ABSOLUTELY NO code comments** (Elixir `#`, Heex `<%#`, HTML `<!--`, etc.). This includes comments explaining rationale, removed code, or historical context. Rely *only* on self-explanatory code and descriptive commit messages (which *can* explain reasoning). This is an inviolable, strict requirement for all code output.

### Planning & Execution Cycle
1.  **Propose Plan:** Detail strategy, including: all files for creation/modification (changes as unified diffs, ~3 lines context; new files with purpose/structure), and any commands to be run.
2.  **Seek Single Approval for Plan:** Wait for explicit approval of the *entire* proposed plan. **Re-confirm before executing potentially destructive commands (e.g., migrations not in the approved plan details) or if significant deviations from the plan become necessary.**
3.  **Execute Approved Plan:** Proceed with all specified file creations/modifications and non-destructive commands. Write file content directly, unless a very small modification (1-2 lines) is clearer shown in full.
4.  **Summarize & Confirm Completion:** After all operations, **list all files actually written/modified.** Then, ask for final approval/confirmation.

### Commit Messages
**Do not use prefixes** like `feat:`, `chore:`, `fix:`, etc. Use clear, descriptive messages.

### Safe Nested Data Access
Prefer `get_in(data.property.other)` for safe, concise access to potentially nil nested data. This avoids `get_in(data, [:property, :other])` syntax and manual nil checks (e.g., `data.a && data.a.b`).

### Context Boundaries
**Strictly keep Ecto Repo interactions within context modules.** Do not call `Repo` functions directly from controllers, LiveViews, components, **schema modules**, or other non-context modules. Contexts should provide the sole interface for database operations.

### Data Pipelines (`|>`)
Strongly favor. Design functions for direct piping (data as first argument). For functions in a pipeline primarily for side-effects, ensure they return the input value to avoid `Kernel.tap/2`. Avoid unnecessary intermediate variables unless they significantly improve readability for a complex value.

### Collection Processing (`Enum` vs. `Stream`)
For multi-step collection processing (e.g., `map`, `filter`), prefer `Stream` functions for lazy computation, materializing with `Enum.to_list/1` only when a list is required. For single `Enum.map` (or similar) operations not in a longer immediate chain, `Enum.map(collection, &mapper/1)` can be clearer than piping.

### Logic Simplification
Critically evaluate conditions within functions. If upstream data processing or queries already guarantee certain data states, remove redundant checks in downstream functions to simplify logic.

### Naming Conventions
Strive for clear, concise, and intention-revealing names for functions and variables. Avoid verbose suffixes (e.g., `_data`, `_list`, `_from_source`) if the context or function signature makes them obvious. Ensure function names accurately reflect their full responsibility.

## Ecto & Database

### Schema Design
Avoid creating redundant schema modules. If an existing schema can represent data at different stages (e.g., before and after persistence, perhaps with different changeset functions), prefer adapting it over creating a new, similar module.

### Migrations (Initial Development)
For schema changes made *before* a feature is stabilized or deployed (especially during initial development or refactoring of a feature not yet merged/released), consider rolling back and modifying the original migration file instead of creating numerous small alteration migrations. This keeps the migration history cleaner for unreleased features.

### Query Optimization
Avoid N+1 query patterns. For checking existence or retrieving multiple related items, prefer batch operations (e.g., querying with `where: field in ^list_of_ids`).

### Changeset Creation
For creating changesets for *new* records from attribute maps/structs, the standard pattern is `YourSchema.changeset(%YourSchema{}, attributes_map \\ %{})`. This lets us call `changeset` without actually having to pass in attributes to it when that's not our intention.

### Ecto Function Behavior
Understand Ecto function behavior with edge cases (e.g., `Repo.insert_all/3` handles empty lists gracefully). Avoid redundant guards if the library function is already robust.

## Key Directories & Files (relative to project root)

- `mix.exs`: Project definition, dependencies. **Check this to see available libraries/APIs.**
- `mix.lock`: Exact dependency versions.
- `lib/`: Core application code (Elixir).
  - `lib/your_app_web/components/`: Often contains reusable UI components (`*_components.ex`) for Eex/Heex templates. (Verify exact path based on app name).
- `test/`: Tests (ExUnit).
- `config/`: Configurations.
- `priv/`: Static files, migrations, templates.
- `assets/`: Frontend assets.

## Common Commands (run from project root)

- `mix setup`: Install deps, setup DB, run migrations.
- `mix phx.server`: Start dev server.
- `mix test`: Run tests.
- `mix format`: Format code.
- `mix deps.get`: Fetch dependencies.
- `mix phx.routes`: List routes.
- `mix ecto.migrate`: Run DB migrations.
- `iex -S mix`: Start interactive console.
