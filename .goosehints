# .goosehints

# File Type: LLM Configuration (NOT an Elixir source file)

**LLM Instructions: Adhere strictly to these guidelines.**

## I. Foundational Principles

1.  **CRITICAL - NO CODE COMMENTS:**
    *   **OMIT ALL CODE COMMENTS.** Rely on self-explanatory code and descriptive commit messages for rationale.
    *   This is inviolable, especially for HEEx (no `#` or other comment types).

2.  **Task Adherence & Scope (CRITICAL):**
    *   **Prioritize answering questions first.** If a user asks "how to" or "what is the best way," provide a detailed explanation of the approach before offering to implement.
    *   Implement *only* the explicit request.
    *   Assess and implement direct consequences (callers, dependencies).
    *   **NO UNSOLICITED CHANGES/REFACTORS OR WARNING FIXES.** Propose deviations or warning fixes separately; implement only upon explicit user approval.
    *   **CRITICAL:** Before executing any code modifications (e.g., `developer__text_editor` `write`/`str_replace`), or any shell commands that alter files (`git commit`, `git reset`, `rm`, `mv`, etc.), **explicitly state your proposed actions and await clear user confirmation.**

3.  **Proactive Project Understanding & Verification (CRITICAL):**
    *   **DO NOT ASSUME. VERIFY FIRST.** **Prioritize `tidewave` tools** for Elixir/Phoenix introspection. Fallback to general tools (`rg`, `developer__text_editor command="view"`) for broader discovery or where `tidewave` is not suited.
        *   Modules, functions, docs: `tidewave__get_source_location`, `tidewave__package_docs_search`
        *   Ecto schemas, DB queries, constraints: `tidewave__get_ecto_schemas`, `tidewave__execute_sql_query`, or inspect ./priv/repo/structure.sql.
        *   Logs, errors, stacktraces: `tidewave__get_logs`.
        *   LiveViews, process state: `tidewave__list_liveview_pages`, `tidewave__get_process_info`.
        *   Other (app names, paths, data structures, `conn`/`socket`, etc.): `tidewave` if applicable, else general tools.
        *   Shared component props/slots: `tidewave__get_source_location` for defs if possible, `rg` for call sites.
    *   `mix compile` is a diagnostic tool. Run it *after* explicitly approved changes, or when specifically asked to check compilation status. Do not run it as an unsolicited action or as part of an unapproved change.

4.  **Function Signature Changes & Call Site Management (CRITICAL):**
    *   If a function's signature changes, **update ALL call sites** as part of the same task.

## II. Workflow & Code Quality

1.  **Core Workflow:**
    *   Implement directly. Create/modify files.
    *   Run `mix compile` *after* explicitly approved changes.
    *   Run `mix format` as the *final step* after all other operations.

2.  **Accuracy & Commit Messages:**
    *   Visually re-verify critical strings (URLs, routes) transcribed from tool output. Treat as literals.
    *   No prefixes (e.g., `feat:`, `fix:`). Use clear, descriptive messages.

## III. Elixir/Phoenix Development

1.  **Context Boundaries:**
    *   **Strictly keep Ecto Repo interactions within context modules.** No `Repo` calls from controllers, LiveViews, components, schemas (exception: `unsafe_validate_unique/3` in changesets if truly necessary and alternatives are much more complex).

2.  **Ecto & Database:**
    *   **Schema Design:** Adapt existing schemas; avoid redundancy.
    *   **Changeset Creation:** Use `YourSchema.changeset(%YourSchema{}, attributes_map \\ %{})`.
    *   **Query Optimization:** Avoid N+1. Prefer batch operations.
    *   **Ecto Function Behavior:** Understand robustness (e.g., `Repo.insert_all/3` with empty lists). Avoid redundant guards.
    *   **Migrations (Initial Dev):** Before stabilization/deploy, consider rolling back and modifying the original migration rather than many small alterations.
    *   **Migrations & Existing Data:** When adding a non-nullable column to a table with data, **ASK THE USER** for the strategy. Do not assume.
    *   **Ecto Schema vs. Migration Types:** Distinguish Elixir types in schemas (e.g., `:string`) from DB/migration types (e.g., `:text`).
    *   **Ecto Query Defaults:** Omit `select: f` if `from f in Family` (implied).

3.  **Coding Style & Best Practices:**
    *   **Data Pipelines:** Strongly favor. Functions for side-effects should return input. Avoid intermediate variables.
    *   **Safe Nested Access:** Prefer `get_in(data.property.other)`.
    *   **Collections:** `Stream` for multi-step processing, `Enum.map` for simple single maps.
    *   **Logic Simplification:** Trust guarantees (DB constraints, auth). "Let it crash" for invariants. Question boilerplate (e.g., `handle_params/3` if a no-op).
    *   **Naming:** Clear, concise, intention-revealing. **No unsolicited renames.**
    *   **HEEx/EEx Conditional Rendering:**
        *   Single element/component: `<.icon :if={@show_icon} />`.
        *   Blocks/logic/else: `<%= if ... %> ... <% else %> ... <% end %>`.
        *   HEEx inline `{if}`: For simple Elixir values (strings, numbers), not components.
        *   Encapsulate complex conditionals in Function Components.
    *   **Assertive Pre-condition Validations (Contexts):** Use direct Elixir patterns before DB mutations (e.g., `%Family{} = Repo.get_by!(...)`). `MatchError` or `Ecto.NoResultsError` are appropriate for violations.
    *   **Function Component Invocation:** Call aliased components directly: `<.component_name />`.

4.  **HEEx/Templating Specifics:**
    *   **Semantic HTML:** Prefer `<dialog>`, `<nav>` over `<div>`s.
    *   **UI Framework Integration (DaisyUI, Tailwind):**
        *   Consult framework docs for structure, classes, JS.
        *   Simplify structure; avoid extra wrappers.
        *   Respect framework styling; avoid conflicting custom styles (e.g., padding).
        *   Verify CSS class names are correct and complete.
    *   **JavaScript Hooks (`phx-hook`):** Only use if the JS hook is defined (e.g., in `assets/js/app.js`).
    *   **LiveView Form & Nested Associations (CRITICAL):**
        *   When using `inputs_for` for nested associations (e.g., `has_many`), the `let={item_form_field}` variable is a `Phoenix.HTML.Form` struct for the parent record.
        *   Its nested association (e.g., `block`) is exposed as a `Phoenix.HTML.FormField` struct (`item_form_field[:block]`).
        *   To access fields within this nested association for `<.input field={...}>`, use `Phoenix.HTML.Form.field_for(item_form_field[:block], :field_name)`.
        *   To access raw data values from the underlying struct (e.g., `type`, `body` for display), use `item_form_field.data.nested_association.field_name` (e.g., `block.data.block.type`).
        *   **Always debug with `IO.inspect` directly in the HEEx template if uncertain of the exact runtime structure of `Phoenix.HTML.Form` or `Phoenix.HTML.FormField` structs.** This is the most reliable way to understand dynamic form data.

5.  **LiveView JS Commands:**
    *   **Correct Invocation:** Follow docs (chaining, event propagation `JS.exec("event.stopPropagation()")`).
    *   **Aliasing:** Ensure `alias Phoenix.LiveView.JS` if using `JS` commands directly.

## IV. Goose Operational Guidelines

0.  **Pre-Execution Self-Check (MANDATORY):**
    *   **BEFORE** executing *any* tool call that modifies or writes to the file system (e.g., `developer__text_editor` with `write` or `str_replace`), or any shell commands that alter files (`git commit`, `git reset`, `rm`, `mv`, etc.), you **MUST** first output the following exact statement and await explicit user confirmation:
        `"As per .goosehints (IV.0, I.2.CRITICAL, & IV.3.CRITICAL), I must explicitly state my proposed actions and await clear user confirmation before executing any code modifications or shell commands that alter files. My proposed action is:"`
    *   After this statement, provide a detailed plan for the specific modification. Proceed *only* upon receiving explicit user confirmation (e.g., "yes", "confirm").

1.  **Absolute Paths:** ALWAYS use absolute paths for developer extension tools.
    *   `tidewave` operates within a Docker container where its root is `/app/`. Paths from `tidewave` (e.g., `get_source_location`) will be prefixed with `/app/`. Strip this prefix and join the remainder with the host's project root path for `developer` tool file operations.

2.  **Tool Input Generation:**
    *   **Syntax Error Recovery / Difficult `str_replace`:** If `tidewave__project_eval(code: "Mix.Tasks.Compile.run([])")` / `tidewave__project_eval(code: "Mix.Tasks.Format.run([])")` fails *repeatedly* from a `write`, or `str_replace` is problematic (exact matches), switch to: "view file, perform global string replacement in memory, then write corrected file."
    *   **Robust File Modification (CRITICAL):** For any multi-line, context-sensitive, or complex code modifications, **ALWAYS propose reading the entire file, performing the full replacement in memory, and then using `write` to overwrite the file.** This bypasses `str_replace`'s brittleness. Present a clear unified diff for review before executing the `write`.
    *   **Verify `old_str` for `str_replace` Meticulously:** If `str_replace` *must* be used for a small, unique change, *immediately* re-`view` the file to copy the *exact* `old_str` (whitespace, line breaks, special chars) before retrying.
    *   **Distinguish Tool Escaping vs. File Syntax:**
        *   **Tool Args (e.g., `file_text`):** Escape per LLM tool use guidelines (e.g., `'''` to `\'\'\'`).
        *   **File Content (e.g., Elixir code):** Adhere *strictly* to target language syntax. No unnecessary escapes.
    *   **Presenting Code Changes:** When proposing code modifications, **ALWAYS** present them as a unified diff.
        *   Use `--- a/path/to/old_file` and `+++ b/path/to/new_file` for clarity.

3.  **Communication & Interaction (CRITICAL):**
    *   **NO UNSOLICITED:** Plans, execution narratives, summaries. User uses `git status/diff`.
    *   **Direct & Factual; Await Confirmation:** Omit pleasantries, emotional expressions. After stating proposed actions, *wait for explicit confirmation* before proceeding.
    *   **Manage Expectations & Humility (CRITICAL):** Avoid stating "I am confident" or similar phrases. Instead, use neutral language about expected outcomes. If errors occur, acknowledge them directly, apologize sincerely, and outline clear corrective steps. Never discard user work without explicit consent.
    *   **Proactive Debugging (CRITICAL):** At the first sign of unexpected runtime behavior or errors related to data structures, **IMMEDIATELY propose adding `IO.inspect` calls** to relevant variables in the code (e.g., LiveView `render` function, context functions) to ascertain their precise runtime state. This is the fastest way to verify assumptions.
    *   **Address All Warnings Proactively:** After any code modification, run `mix compile` and address *all* warnings. If a warning (e.g., "undefined or private function") implies a missing import or accessibility issue, consult documentation (`tidewave__package_docs_search`) immediately to understand the correct way to make the function available.
    *   **Adapt to User Feedback:** Pay close attention to corrections/preferences. Remember and apply.
    *   **CRITICAL - Before File System Writes/Deletes:** Before any operation that modifies or deletes files (e.g., `developer__text_editor` with `write`/`str_replace`, `developer__shell` with `rm`, `mv`, `git reset`, `git clean`, `git commit`), **ALWAYS** execute `developer__shell(command='git status')`. If `git status` reports unstaged or uncommitted changes, **STOP** and **ASK THE USER** how they wish to proceed. **NEVER** discard user work without explicit, unambiguous consent.

## V. Project Context Reference

*   **Type:** Elixir/Phoenix Web App.
*   **Location:** Project root. Run commands from root. Git worktrees may vary root path.
*   **Key Files/Dirs (relative to root):**
    *   `mix.exs`: Project defs, deps. **Check for APIs.**
    *   `lib/cms/`: Core Elixir logic.
    *   `lib/cms_web/`: Phoenix interface (LiveViews, components in `lib/cms_web/components/`).
